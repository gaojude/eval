/**
 * Claude Code agent execution in sandbox.
 */

import type { ModelTier, SetupFunction } from './types.js';
import {
  SandboxManager,
  collectLocalFiles,
  splitTestFiles,
  verifyNoTestFiles,
} from './sandbox.js';

/**
 * Options for running the agent.
 */
export interface AgentRunOptions {
  /** The prompt/task for the agent */
  prompt: string;
  /** Claude model tier to use */
  model: ModelTier;
  /** Timeout in milliseconds */
  timeout: number;
  /** Anthropic API key */
  apiKey: string;
  /** Optional setup function to run before agent */
  setup?: SetupFunction;
  /** npm scripts to run after agent completes */
  scripts?: string[];
}

/**
 * Result of an agent run.
 */
export interface AgentRunResult {
  /** Whether the run was successful */
  success: boolean;
  /** Raw output from the agent */
  output: string;
  /** Error message if failed */
  error?: string;
  /** Duration in milliseconds */
  duration: number;
  /** Build script success */
  buildSuccess?: boolean;
  /** Lint script success */
  lintSuccess?: boolean;
  /** Test success */
  testSuccess?: boolean;
  /** Build output */
  buildOutput?: string;
  /** Lint output */
  lintOutput?: string;
  /** Test output */
  testOutput?: string;
  /** Sandbox ID for debugging */
  sandboxId?: string;
  /** Files generated by the agent */
  generatedFiles?: Record<string, string>;
}

/**
 * Run the Claude Code agent on a fixture in an isolated sandbox.
 *
 * The workflow is:
 * 1. Create sandbox and upload workspace files (excluding tests)
 * 2. Run setup function if provided
 * 3. Install dependencies
 * 4. Run Claude Code with the prompt
 * 5. Upload test files after agent completes
 * 6. Run validation (build, lint, tests)
 */
export async function runAgent(
  fixturePath: string,
  options: AgentRunOptions
): Promise<AgentRunResult> {
  const startTime = Date.now();
  let sandbox: SandboxManager | null = null;
  let agentOutput = '';

  try {
    // Collect files from fixture
    const allFiles = await collectLocalFiles(fixturePath);
    const { workspaceFiles, testFiles } = splitTestFiles(allFiles);

    // Create sandbox
    sandbox = await SandboxManager.create({
      timeout: options.timeout,
      runtime: 'node24',
    });

    // Upload workspace files (excluding tests)
    await sandbox.uploadFiles(workspaceFiles);

    // Run setup function if provided
    if (options.setup) {
      await options.setup(sandbox);
    }

    // Install dependencies
    const installResult = await sandbox.runCommand('npm', ['install']);
    if (installResult.exitCode !== 0) {
      throw new Error(`npm install failed: ${installResult.stderr}`);
    }

    // Install Claude Code CLI globally
    const cliInstall = await sandbox.runCommand('npm', [
      'install',
      '-g',
      '@anthropic-ai/claude-code',
    ]);
    if (cliInstall.exitCode !== 0) {
      throw new Error(`Claude Code install failed: ${cliInstall.stderr}`);
    }

    // Verify no test files in sandbox
    await verifyNoTestFiles(sandbox);

    // Prepare enhanced prompt
    const enhancedPrompt = `${options.prompt.trim()}

IMPORTANT: Do not run npm, pnpm, yarn, or any package manager commands. Dependencies have already been installed. Do not run build, test, or dev server commands. Just write the code files.`;

    // Run Claude Code
    const claudeResult = await sandbox.runCommand(
      'claude',
      ['--print', '--model', options.model, '--dangerously-skip-permissions', enhancedPrompt],
      { env: { ANTHROPIC_API_KEY: options.apiKey } }
    );

    agentOutput = claudeResult.stdout + claudeResult.stderr;

    if (claudeResult.exitCode !== 0) {
      return {
        success: false,
        output: agentOutput,
        error: `Claude Code exited with code ${claudeResult.exitCode}`,
        duration: Date.now() - startTime,
        sandboxId: sandbox.sandboxId,
      };
    }

    // Upload test files for validation
    await sandbox.uploadFiles(testFiles);

    // Create vitest config that includes EVAL.ts
    await sandbox.writeFiles({
      'vitest.config.ts': `
import { defineConfig } from 'vitest/config';
export default defineConfig({
  test: {
    include: ['EVAL.ts'],
    globals: false,
  },
});
`,
    });

    // Run validation scripts
    const validationResults = await runValidation(sandbox, options.scripts ?? []);

    // Capture generated files
    const generatedFiles = await captureGeneratedFiles(sandbox);

    return {
      success: validationResults.allPassed,
      output: agentOutput,
      duration: Date.now() - startTime,
      buildSuccess: validationResults.build?.success,
      lintSuccess: validationResults.lint?.success,
      testSuccess: validationResults.test?.success,
      buildOutput: validationResults.build?.output,
      lintOutput: validationResults.lint?.output,
      testOutput: validationResults.test?.output,
      sandboxId: sandbox.sandboxId,
      generatedFiles,
    };
  } catch (error) {
    return {
      success: false,
      output: agentOutput,
      error: error instanceof Error ? error.message : String(error),
      duration: Date.now() - startTime,
      sandboxId: sandbox?.sandboxId,
    };
  } finally {
    if (sandbox) {
      await sandbox.stop();
    }
  }
}

/**
 * Validation result from running a script.
 */
interface ScriptResult {
  success: boolean;
  output: string;
}

/**
 * Combined validation results.
 */
interface ValidationResults {
  allPassed: boolean;
  build?: ScriptResult;
  lint?: ScriptResult;
  test?: ScriptResult;
  scripts: Record<string, ScriptResult>;
}

/**
 * Run validation scripts in the sandbox.
 */
async function runValidation(
  sandbox: SandboxManager,
  scripts: string[]
): Promise<ValidationResults> {
  const results: ValidationResults = {
    allPassed: true,
    scripts: {},
  };

  // Always run vitest for EVAL.ts (explicitly specify the file)
  const testResult = await sandbox.runCommand('npx', ['vitest', 'run', 'EVAL.ts']);
  results.test = {
    success: testResult.exitCode === 0,
    output: testResult.stdout + testResult.stderr,
  };
  if (!results.test.success) {
    results.allPassed = false;
  }

  // Run configured scripts
  for (const script of scripts) {
    const scriptResult = await sandbox.runCommand('npm', ['run', script]);
    const result: ScriptResult = {
      success: scriptResult.exitCode === 0,
      output: scriptResult.stdout + scriptResult.stderr,
    };

    results.scripts[script] = result;

    // Map common script names to result fields
    if (script === 'build') {
      results.build = result;
    } else if (script === 'lint') {
      results.lint = result;
    }

    if (!result.success) {
      results.allPassed = false;
    }
  }

  return results;
}

/**
 * Capture source files generated by the agent.
 */
async function captureGeneratedFiles(sandbox: SandboxManager): Promise<Record<string, string>> {
  const files: Record<string, string> = {};

  try {
    // Find all source files
    const findResult = await sandbox.runShell(
      "find . -path './node_modules' -prune -o \\( -name '*.ts' -o -name '*.tsx' -o -name '*.js' -o -name '*.jsx' \\) -type f -print"
    );

    const filePaths = findResult.stdout
      .trim()
      .split('\n')
      .filter(Boolean);

    for (const filePath of filePaths) {
      try {
        const content = await sandbox.readFile(filePath);
        files[filePath] = content;
      } catch {
        // Skip unreadable files
      }
    }
  } catch {
    // If capture fails, return empty object
  }

  return files;
}

/**
 * Get the model ID for a model tier.
 */
export function getModelId(tier: ModelTier): string {
  switch (tier) {
    case 'opus':
      return 'claude-opus-4-5-20251101';
    case 'sonnet':
      return 'claude-sonnet-4-20250514';
    case 'haiku':
      return 'claude-haiku-3-5-20241022';
  }
}
